## How a dirty cow exploit works

### 1. Map the file we want to edit in virtual memory in CoW mode

```
int f = open(suid_binary,O_RDONLY);
struct stat st;
fstat(f,&st);
void *map = mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);
```
- `suid_binary` is a string that contains the name of the file we want to modify
- We open this file and get a file descriptor on it in `f`
- We use `fstat` to get the size of the target file in `st.st_size`
- We ask the kernel to map the file to our virtual memory with `mmap`
    - `NULL` means we don't request a specific mapping location in virtual memory
    - `PROT_READ` means that we only request read access to the original file
    - `MAP_PRIVATE` means that this is a copy on write mapping, i.e. updates to this virtual memory area are allowed but are not written to the original file.

### 2. Repeatedly write date on the mapped area
Open `/proc/self/mem`, which is the linux pseudo-file representing the virtual memory of our process :

```
int f=open("/proc/self/mem",O_RDWR);
```

Then repeat the following code :
```
lseek(f, map, SEEK_SET);
write(f, str, len);
```
- `lseek` tells that we are going to write at the location `map`
- `str` is the data that we want to write in the target file, `len` is its length

Why do we use `/proc/self/mem` instead of directly writing in the memory area that `map` points to ?
Because using `/proc/self/mem` makes the kernel use code that is intended to allow a process to access memory of another process, and that is this code that contains the vulnerability. Even though here we access the memory of our own process, we need to do it in a way that allows us to exploit the vulnerable kernel code.

### 3. Concurrently tell the kernel to free the resources associated whith the mapped area
In a second thread, repeat the following code, such that it runs concurrently to the code in point 2.
```
madvise(map,100,MADV_DONTNEED);
```
This will tell the kernel to unallocate the memory page for the mapped area. After that, accessing to the mapped area is still allowed but the data will have to be reloaded from the disk.

If this code is executed in the middle of the `write` of step 2, it may trigger a race condition bug.
In this case the copy on write mechanism does not work properly, and the `write` ends up to be performed on the original target file.
